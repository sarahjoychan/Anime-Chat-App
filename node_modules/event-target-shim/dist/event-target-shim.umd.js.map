{"version":3,"file":"event-target-shim.umd.js.map","sources":["../src/event.mjs","../src/event-target.mjs"],"sourcesContent":["/**\n * @typedef {object} PrivateData\n * @property {EventTarget} eventTarget The event target.\n * @property {{type:string}} event The original event object.\n * @property {number} eventPhase The current event phase.\n * @property {EventTarget|null} currentTarget The current event target.\n * @property {boolean} canceled The flag to prevent default.\n * @property {boolean} stopped The flag to stop propagation immediately.\n * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.\n * @property {number} timeStamp The unix time.\n * @private\n */\n\n/**\n * Private data for event wrappers.\n * @type {WeakMap<Event, PrivateData>}\n * @private\n */\nconst privateData = new WeakMap()\n\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */\nconst wrappers = new WeakMap()\n\n/**\n * Get private data.\n * @param {Event} event The event object to get private data.\n * @returns {PrivateData} The private data of the event.\n * @private\n */\nfunction pd(event) {\n    const retv = privateData.get(event)\n    console.assert(retv != null, \"'this' is expected an Event object, but got\", event)\n    return retv\n}\n\n/**\n * @see https://dom.spec.whatwg.org/#interface-event\n * @private\n */\n/**\n * The event wrapper.\n * @constructor\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Event|{type:string}} event The original event to wrap.\n */\nfunction Event(eventTarget, event) {\n    privateData.set(this, {\n        eventTarget,\n        event,\n        eventPhase: 2,\n        currentTarget: eventTarget,\n        canceled: false,\n        stopped: false,\n        passiveListener: null,\n        timeStamp: event.timeStamp || Date.now(),\n    })\n\n    // https://heycam.github.io/webidl/#Unforgeable\n    Object.defineProperty(this, \"isTrusted\", { value: false, enumerable: true })\n\n    // Define accessors\n    const keys = Object.keys(event)\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i]\n        if (!(key in this)) {\n            Object.defineProperty(this, key, defineRedirectDescriptor(key))\n        }\n    }\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEvent.prototype = {\n    /**\n     * The type of this event.\n     * @type {string}\n     */\n    get type() {\n        return pd(this).event.type\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get target() {\n        return pd(this).eventTarget\n    },\n\n    /**\n     * The target of this event.\n     * @type {EventTarget}\n     */\n    get currentTarget() {\n        return pd(this).currentTarget\n    },\n\n    /**\n     * @returns {EventTarget[]} The composed path of this event.\n     */\n    composedPath() {\n        const currentTarget = pd(this).currentTarget\n        if (currentTarget == null) {\n            return []\n        }\n        return [currentTarget]\n    },\n\n    /**\n     * Constant of NONE.\n     * @type {number}\n     */\n    get NONE() {\n        return 0\n    },\n\n    /**\n     * Constant of CAPTURING_PHASE.\n     * @type {number}\n     */\n    get CAPTURING_PHASE() {\n        return 1\n    },\n\n    /**\n     * Constant of AT_TARGET.\n     * @type {number}\n     */\n    get AT_TARGET() {\n        return 2\n    },\n\n    /**\n     * Constant of BUBBLING_PHASE.\n     * @type {number}\n     */\n    get BUBBLING_PHASE() {\n        return 3\n    },\n\n    /**\n     * The target of this event.\n     * @type {number}\n     */\n    get eventPhase() {\n        return pd(this).eventPhase\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopPropagation() {\n        const data = pd(this)\n        if (typeof data.event.stopPropagation === \"function\") {\n            data.event.stopPropagation()\n        }\n    },\n\n    /**\n     * Stop event bubbling.\n     * @returns {void}\n     */\n    stopImmediatePropagation() {\n        const data = pd(this)\n\n        data.stopped = true\n        if (typeof data.event.stopImmediatePropagation === \"function\") {\n            data.event.stopImmediatePropagation()\n        }\n    },\n\n    /**\n     * The flag to be bubbling.\n     * @type {boolean}\n     */\n    get bubbles() {\n        return Boolean(pd(this).event.bubbles)\n    },\n\n    /**\n     * The flag to be cancelable.\n     * @type {boolean}\n     */\n    get cancelable() {\n        return Boolean(pd(this).event.cancelable)\n    },\n\n    /**\n     * Cancel this event.\n     * @returns {void}\n     */\n    preventDefault() {\n        const data = pd(this)\n        if (data.passiveListener != null) {\n            console.warn(\"Event#preventDefault() was called from a passive listener:\", data.passiveListener)\n            return\n        }\n        if (!data.event.cancelable) {\n            return\n        }\n\n        data.canceled = true\n        if (typeof data.event.preventDefault === \"function\") {\n            data.event.preventDefault()\n        }\n    },\n\n    /**\n     * The flag to indicate cancellation state.\n     * @type {boolean}\n     */\n    get defaultPrevented() {\n        return pd(this).canceled\n    },\n\n    /**\n     * The flag to be composed.\n     * @type {boolean}\n     */\n    get composed() {\n        return Boolean(pd(this).event.composed)\n    },\n\n    /**\n     * The unix time of this event.\n     * @type {number}\n     */\n    get timeStamp() {\n        return pd(this).timeStamp\n    },\n}\n\n// `constructor` is not enumerable.\nObject.defineProperty(Event.prototype, \"constructor\", { value: Event, configurable: true, writable: true })\n\n// Ensure `event instanceof window.Event` is `true`.\nif (typeof window !== \"undefined\" && typeof window.Event !== \"undefined\") {\n    Object.setPrototypeOf(Event.prototype, window.Event.prototype)\n\n    // Make association for wrappers.\n    wrappers.set(window.Event.prototype, Event)\n}\n\n/**\n * Get the property descriptor to redirect a given property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to redirect the property.\n * @private\n */\nfunction defineRedirectDescriptor(key) {\n    return {\n        get() {\n            return pd(this).event[key]\n        },\n        set(value) {\n            pd(this).event[key] = value\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Get the property descriptor to call a given method property.\n * @param {string} key Property name to define property descriptor.\n * @returns {PropertyDescriptor} The property descriptor to call the method property.\n * @private\n */\nfunction defineCallDescriptor(key) {\n    return {\n        value() {\n            const event = pd(this).event\n            return event[key].apply(event, arguments)\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define new wrapper class.\n * @param {Function} BaseEvent The base wrapper class.\n * @param {Object} proto The prototype of the original event.\n * @returns {Function} The defined wrapper class.\n * @private\n */\nfunction defineWrapper(BaseEvent, proto) {\n    const keys = Object.keys(proto)\n    if (keys.length === 0) {\n        return BaseEvent\n    }\n\n    /** CustomEvent */\n    function CustomEvent(eventTarget, event) {\n        BaseEvent.call(this, eventTarget, event)\n    }\n\n    CustomEvent.prototype = Object.create(BaseEvent.prototype, {\n        constructor: { value: CustomEvent, configurable: true, writable: true },\n    })\n\n    // Define accessors.\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i]\n        if (!(key in BaseEvent.prototype)) {\n            const descriptor = Object.getOwnPropertyDescriptor(proto, key)\n            const isFunc = (typeof descriptor.value === \"function\")\n            Object.defineProperty(\n                CustomEvent.prototype,\n                key,\n                isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key)\n            )\n        }\n    }\n\n    return CustomEvent\n}\n\n/**\n * Get the wrapper class of a given prototype.\n * @param {Object} proto The prototype of the original event to get its wrapper.\n * @returns {Function} The wrapper class.\n * @private\n */\nfunction getWrapper(proto) {\n    if (proto == null || proto === Object.prototype) {\n        return Event\n    }\n\n    let wrapper = wrappers.get(proto)\n    if (wrapper == null) {\n        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto)\n        wrappers.set(proto, wrapper)\n    }\n    return wrapper\n}\n\n/**\n * Wrap a given event to management a dispatching.\n * @param {EventTarget} eventTarget The event target of this dispatching.\n * @param {Object} event The event to wrap.\n * @returns {Event} The wrapper instance.\n * @private\n */\nexport function wrapEvent(eventTarget, event) {\n    const Wrapper = getWrapper(Object.getPrototypeOf(event))\n    return new Wrapper(eventTarget, event)\n}\n\n/**\n * Get the stopped flag of a given event.\n * @param {Event} event The event to get.\n * @returns {boolean} The flag to stop propagation immediately.\n * @private\n */\nexport function isStopped(event) {\n    return pd(event).stopped\n}\n\n/**\n * Set the current event phase of a given event.\n * @param {Event} event The event to set current target.\n * @param {number} eventPhase New event phase.\n * @returns {void}\n * @private\n */\nexport function setEventPhase(event, eventPhase) {\n    pd(event).eventPhase = eventPhase\n}\n\n/**\n * Set the current target of a given event.\n * @param {Event} event The event to set current target.\n * @param {EventTarget|null} currentTarget New current target.\n * @returns {void}\n * @private\n */\nexport function setCurrentTarget(event, currentTarget) {\n    pd(event).currentTarget = currentTarget\n}\n\n/**\n * Set a passive listener of a given event.\n * @param {Event} event The event to set current target.\n * @param {Function|null} passiveListener New passive listener.\n * @returns {void}\n * @private\n */\nexport function setPassiveListener(event, passiveListener) {\n    pd(event).passiveListener = passiveListener\n}\n","import { isStopped, setCurrentTarget, setEventPhase, setPassiveListener, wrapEvent } from \"./event.mjs\"\n\n/**\n * @typedef {object} ListenerNode\n * @property {Function} listener\n * @property {1|2|3} listenerType\n * @property {boolean} passive\n * @property {boolean} once\n * @property {ListenerNode|null} next\n * @private\n */\n\n/**\n * @type {WeakMap<object, Map<string, ListenerNode>>}\n * @private\n */\nconst listenersMap = new WeakMap()\n\n// Listener types\nconst CAPTURE = 1\nconst BUBBLE = 2\nconst ATTRIBUTE = 3\n\n/**\n * Check whether a given value is an object or not.\n * @param {any} x The value to check.\n * @returns {boolean} `true` if the value is an object.\n */\nfunction isObject(x) {\n    return x !== null && typeof x === \"object\" //eslint-disable-line no-restricted-syntax\n}\n\n/**\n * Get listeners.\n * @param {EventTarget} eventTarget The event target to get.\n * @returns {Map<string, ListenerNode>} The listeners.\n * @private\n */\nfunction getListeners(eventTarget) {\n    const listeners = listenersMap.get(eventTarget)\n    if (listeners == null) {\n        throw new TypeError(\"'this' is expected an EventTarget object, but got another value.\")\n    }\n    return listeners\n}\n\n/**\n * Get the property descriptor for the event attribute of a given event.\n * @param {string} eventName The event name to get property descriptor.\n * @returns {PropertyDescriptor} The property descriptor.\n * @private\n */\nfunction defineEventAttributeDescriptor(eventName) {\n    return {\n        get() {\n            const listeners = getListeners(this)\n            let node = listeners.get(eventName)\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    return node.listener\n                }\n                node = node.next\n            }\n            return null\n        },\n\n        set(listener) {\n            if (typeof listener !== \"function\" && !isObject(listener)) {\n                listener = null // eslint-disable-line no-param-reassign\n            }\n            const listeners = getListeners(this)\n\n            // Traverse to the tail while removing old value.\n            let prev = null\n            let node = listeners.get(eventName)\n            while (node != null) {\n                if (node.listenerType === ATTRIBUTE) {\n                    // Remove old value.\n                    if (prev !== null) {\n                        prev.next = node.next\n                    }\n                    else if (node.next !== null) {\n                        listeners.set(eventName, node.next)\n                    }\n                    else {\n                        listeners.delete(eventName)\n                    }\n                }\n                else {\n                    prev = node\n                }\n\n                node = node.next\n            }\n\n            // Add new value.\n            if (listener !== null) {\n                const newNode = {\n                    listener,\n                    listenerType: ATTRIBUTE,\n                    passive: false,\n                    once: false,\n                    next: null,\n                }\n                if (prev === null) {\n                    listeners.set(eventName, newNode)\n                }\n                else {\n                    prev.next = newNode\n                }\n            }\n        },\n        configurable: true,\n        enumerable: true,\n    }\n}\n\n/**\n * Define an event attribute (e.g. `eventTarget.onclick`).\n * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.\n * @param {string} eventName The event name to define.\n * @returns {void}\n */\nfunction defineEventAttribute(eventTargetPrototype, eventName) {\n    Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName))\n}\n\n/**\n * Define a custom EventTarget with event attributes.\n * @param {string[]} eventNames Event names for event attributes.\n * @returns {EventTarget} The custom EventTarget.\n * @private\n */\nfunction defineCustomEventTarget(eventNames) {\n    /** CustomEventTarget */\n    function CustomEventTarget() {\n        EventTarget.call(this)\n    }\n\n    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {\n        constructor: { value: CustomEventTarget, configurable: true, writable: true },\n    })\n\n    for (let i = 0; i < eventNames.length; ++i) {\n        defineEventAttribute(CustomEventTarget.prototype, eventNames[i])\n    }\n\n    return CustomEventTarget\n}\n\n/**\n * EventTarget.\n *\n * - This is constructor if no arguments.\n * - This is a function which returns a CustomEventTarget constructor if there are arguments.\n *\n * For example:\n *\n *     class A extends EventTarget {}\n *     class B extends EventTarget(\"message\") {}\n *     class C extends EventTarget(\"message\", \"error\") {}\n *     class D extends EventTarget([\"message\", \"error\"]) {}\n */\nfunction EventTarget() {\n    /*eslint-disable consistent-return */\n    if (this instanceof EventTarget) {\n        listenersMap.set(this, new Map())\n        return\n    }\n    if (arguments.length === 1 && Array.isArray(arguments[0])) {\n        return defineCustomEventTarget(arguments[0])\n    }\n    if (arguments.length > 0) {\n        const types = new Array(arguments.length)\n        for (let i = 0; i < arguments.length; ++i) {\n            types[i] = arguments[i]\n        }\n        return defineCustomEventTarget(types)\n    }\n    throw new TypeError(\"Cannot call a class as a function\")\n    /*eslint-enable consistent-return */\n}\n\n// Should be enumerable, but class methods are not enumerable.\nEventTarget.prototype = {\n    /**\n     * Add a given listener to this event target.\n     * @param {string} eventName The event name to add.\n     * @param {Function} listener The listener to add.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {boolean} `true` if the listener was added actually.\n     */\n    addEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return false\n        }\n        if (typeof listener !== \"function\" && !isObject(listener)) {\n            throw new TypeError(\"'listener' should be a function or an object.\")\n        }\n\n        const listeners = getListeners(this)\n        const optionsIsObj = isObject(options)\n        const capture = optionsIsObj ? Boolean(options.capture) : Boolean(options)\n        const listenerType = (capture ? CAPTURE : BUBBLE)\n        const newNode = {\n            listener,\n            listenerType,\n            passive: optionsIsObj && Boolean(options.passive),\n            once: optionsIsObj && Boolean(options.once),\n            next: null,\n        }\n\n        // Set it as the first node if the first node is null.\n        let node = listeners.get(eventName)\n        if (node === undefined) {\n            listeners.set(eventName, newNode)\n            return true\n        }\n\n        // Traverse to the tail while checking duplication..\n        let prev = null\n        while (node != null) {\n            if (node.listener === listener && node.listenerType === listenerType) {\n                // Should ignore duplication.\n                return false\n            }\n            prev = node\n            node = node.next\n        }\n\n        // Add it.\n        prev.next = newNode\n        return true\n    },\n\n    /**\n     * Remove a given listener from this event target.\n     * @param {string} eventName The event name to remove.\n     * @param {Function} listener The listener to remove.\n     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.\n     * @returns {boolean} `true` if the listener was removed actually.\n     */\n    removeEventListener(eventName, listener, options) {\n        if (listener == null) {\n            return false\n        }\n\n        const listeners = getListeners(this)\n        const capture = isObject(options) ? Boolean(options.capture) : Boolean(options)\n        const listenerType = (capture ? CAPTURE : BUBBLE)\n\n        let prev = null\n        let node = listeners.get(eventName)\n        while (node != null) {\n            if (node.listener === listener && node.listenerType === listenerType) {\n                if (prev !== null) {\n                    prev.next = node.next\n                }\n                else if (node.next !== null) {\n                    listeners.set(eventName, node.next)\n                }\n                else {\n                    listeners.delete(eventName)\n                }\n                return true\n            }\n\n            prev = node\n            node = node.next\n        }\n\n        return false\n    },\n\n    /**\n     * Dispatch a given event.\n     * @param {Event|{type:string}} event The event to dispatch.\n     * @returns {boolean} `false` if canceled.\n     */\n    dispatchEvent(event) { //eslint-disable-line complexity\n        if (event == null || typeof event.type !== \"string\") {\n            throw new TypeError(\"\\\"event.type\\\" should be a string.\")\n        }\n\n        // If listeners aren't registered, terminate.\n        const listeners = getListeners(this)\n        const eventName = event.type\n        let node = listeners.get(eventName)\n        if (node == null) {\n            return true\n        }\n\n        // Since we cannot rewrite several properties, so wrap object.\n        const wrappedEvent = wrapEvent(this, event)\n\n        // This doesn't process capturing phase and bubbling phase.\n        // This isn't participating in a tree.\n        let prev = null\n        while (node != null) {\n            // Remove this listener if it's once\n            if (node.once) {\n                if (prev !== null) {\n                    prev.next = node.next\n                }\n                else if (node.next !== null) {\n                    listeners.set(eventName, node.next)\n                }\n                else {\n                    listeners.delete(eventName)\n                }\n            }\n            else {\n                prev = node\n            }\n\n            // Call this listener\n            setPassiveListener(wrappedEvent, (node.passive ? node.listener : null))\n            if (typeof node.listener === \"function\") {\n                try {\n                    node.listener.call(this, wrappedEvent)\n                }\n                catch (err) {\n                    /*eslint-disable no-console */\n                    if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n                        console.error(err)\n                    }\n                    /*eslint-enable no-console */\n                }\n            }\n            else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === \"function\") {\n                node.listener.handleEvent(wrappedEvent)\n            }\n\n            // Break if `event.stopImmediatePropagation` was called.\n            if (isStopped(wrappedEvent)) {\n                break\n            }\n\n            node = node.next\n        }\n        setPassiveListener(wrappedEvent, null)\n        setEventPhase(wrappedEvent, 0)\n        setCurrentTarget(wrappedEvent, null)\n\n        return !wrappedEvent.defaultPrevented\n    },\n}\n\n// `constructor` is not enumerable.\nObject.defineProperty(EventTarget.prototype, \"constructor\", { value: EventTarget, configurable: true, writable: true })\n\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (typeof window !== \"undefined\" && typeof window.EventTarget !== \"undefined\") {\n    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype)\n}\n\nexport { defineEventAttribute, EventTarget }\nexport default EventTarget\n"],"names":["pd","event","retv","privateData","get","assert","Event","eventTarget","set","timeStamp","Date","now","defineProperty","value","enumerable","key","keys","Object","i","length","defineRedirectDescriptor","defineCallDescriptor","apply","arguments","defineWrapper","BaseEvent","proto","CustomEvent","call","prototype","create","configurable","writable","descriptor","getOwnPropertyDescriptor","isFunc","getWrapper","wrapper","wrappers","getPrototypeOf","wrapEvent","Wrapper","isStopped","stopped","setEventPhase","eventPhase","setCurrentTarget","currentTarget","setPassiveListener","passiveListener","isObject","x","getListeners","listeners","listenersMap","TypeError","defineEventAttributeDescriptor","eventName","node","listenerType","listener","next","prev","delete","newNode","defineEventAttribute","eventTargetPrototype","defineCustomEventTarget","eventNames","CustomEventTarget","EventTarget","Map","Array","isArray","types","WeakMap","type","target","NONE","CAPTURING_PHASE","AT_TARGET","BUBBLING_PHASE","data","stopPropagation","stopImmediatePropagation","bubbles","cancelable","canceled","preventDefault","warn","defaultPrevented","composed","window","setPrototypeOf","options","optionsIsObj","capture","passive","once","wrappedEvent","err","console","error","handleEvent"],"mappings":"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"}